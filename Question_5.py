# -*- coding: utf-8 -*-
"""Question-5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YXTxCQXPSKvHnKUlmq_j_BOsvh3U0FQR

Without Sideways Moves
"""

import random

def generate_random_state():
    return random.sample(range(8), 8)

def evaluate_state(state):
    # Heuristic...
    conflicts = 0
    for i in range(8):
        for j in range(i+1, 8):
            if state[i] == state[j] or abs(i - j) == abs(state[i] - state[j]):
                conflicts += 1
    return conflicts

def steepest_ascent_hill_climbing():
    state = generate_random_state()
    steps = 0

    while True:
        current_value = evaluate_state(state)

        if current_value == 0:
            return steps  # Success

        neighbors = []
        for i in range(8):
            for j in range(8):
                if j != state[i]:
                    neighbor = state[:]
                    neighbor[i] = j
                    neighbors.append(neighbor)

        best_neighbor = min(neighbors, key=evaluate_state)

        if evaluate_state(best_neighbor) >= current_value:
            return steps  # Stuck

        state = best_neighbor
        steps += 1

success_count = 0
fail_count = 0
success_steps = 0
fail_steps = 0

for _ in range(1000):
    steps = steepest_ascent_hill_climbing()
    if steps == 0:
        success_count += 1
    else:
        fail_count += 1
        fail_steps += steps

if success_count > 0:
    success_steps = success_steps / success_count

print("Success rate:", success_count / 1000)
print("Average steps when succeeding:", success_steps)
print("Average steps when failing:", fail_steps / fail_count)

"""With Sideways Moves"""

import random

def generate_random_state():
    return random.sample(range(8), 8)

def evaluate_state(state):
    # Heuristic...
    conflicts = 0
    for i in range(8):
        for j in range(i+1, 8):
            if state[i] == state[j] or abs(i - j) == abs(state[i] - state[j]):
                conflicts += 1
    return conflicts

def steepest_ascent_hill_climbing_with_sideways(max_sideways_moves=3):
    success_count = 0
    fail_count = 0
    success_steps = 0
    fail_steps = 0

    for _ in range(1000):
        state = generate_random_state()
        steps = 0
        sideways_moves = 0

        while True:
            current_value = evaluate_state(state)

            if current_value == 0:
                success_count += 1
                success_steps += steps
                break  # Success

            neighbors = []
            for i in range(8):
                for j in range(8):
                    if j != state[i]:
                        neighbor = state[:]
                        neighbor[i] = j
                        neighbors.append(neighbor)

            best_neighbor = min(neighbors, key=evaluate_state)

            if evaluate_state(best_neighbor) >= current_value:
                if sideways_moves < max_sideways_moves:
                    sideways_moves += 1
                else:
                    fail_count += 1
                    fail_steps += steps
                    break  # Stuck after reaching the maximum sideways moves

            state = best_neighbor
            steps += 1

    if success_count > 0:
        success_steps = success_steps / success_count

    return success_count, fail_count, success_steps, fail_steps

success_count, fail_count, success_steps, fail_steps = steepest_ascent_hill_climbing_with_sideways()

print("Success rate:", success_count / (success_count + fail_count))
print("Failure rate:", fail_count / (success_count + fail_count))
print("Average steps when succeeding:", success_steps)
print("Average steps when failing:", fail_steps / fail_count)