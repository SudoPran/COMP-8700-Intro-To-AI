# -*- coding: utf-8 -*-
"""Missionaries and Cannibals (BFS and DFS).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rjIfO4AmsYt8St-rj_XKOr1lAMfQhiEA
"""

def get_initial_state():
    return ((3, 3), (0, 0), 'l')

def is_goal_state(state):
    return state == ((0, 0), (3, 3), 'r')

def is_valid_state(state):
    left_position, right_position, boat_position = state
    return 0 <= left_position[0] <= 3 and 0 <= left_position[1] <= 3 and 0 <= right_position[0] <= 3 and 0 <= right_position[1] <= 3 \
    and not((left_position[0] < left_position[1] and left_position[0] > 0) or (right_position[0] < right_position[1] and right_position[0] > 0))

def get_next_possible_states(current_state):
    left_pos, right_pos, boat_pos = current_state
    next_states = []

    if boat_pos == 'l':
        left_right_possible = [(0, 1), (0, 2), (1, 1), (1, 0), (2, 0)]
        for pos in left_right_possible:
            new_left_pos = (left_pos[0] - pos[0], left_pos[1] - pos[1])
            new_right_pos = (right_pos[0] + pos[0], right_pos[1] + pos[1])
            if is_valid_state((new_left_pos, new_right_pos, 'r')):
                next_states.append((new_left_pos, new_right_pos, 'r'))
    else:
        right_left_possible = [(1, 0), (0, 1), (1, 1)]
        for pos in right_left_possible:
            new_left_pos = (left_pos[0] + pos[0], left_pos[1] + pos[1])
            new_right_pos = (right_pos[0] - pos[0], right_pos[1] - pos[1])
            if is_valid_state((new_left_pos, new_right_pos, 'l')):
                next_states.append((new_left_pos, new_right_pos, 'l'))

    return next_states

from collections import deque

def bfs(init):
    visited = set()
    queue = deque([(init, [init])])

    while queue:
        current_state, path = queue.popleft()
        print('Current State: ', current_state)
        if is_goal_state(current_state):
            return path

        visited.add(current_state)
        next_possible_states = get_next_possible_states(current_state)
        print('Next Possible States: ', next_possible_states)
        for next_state in next_possible_states:
            if next_state not in visited:
                queue.append((next_state, path + [next_state]))

    return None

def dfs(current_state, path, visited):
    print('Current State: ', current_state)
    if is_goal_state(current_state):
        return path

    visited.add(current_state)
    next_possible_states = get_next_possible_states(current_state)
    print('Next Possible States: ', next_possible_states)
    for next_state in next_possible_states:
        if next_state not in visited:
            result = dfs(next_state, path + [next_state], visited)
            if result is not None:
                return result

    return None

def heuristic(state):
    left, right, boat = state

    return left[0] + left[1]

from queue import PriorityQueue

def greedy_best_first_search(init):
    priority_queue = PriorityQueue()
    priority_queue.put((heuristic(init), init))
    visited = set()
    path = []

    while priority_queue:
        current_state = priority_queue.get()[1]
        path = path + [current_state]
        print('Current State: ', current_state)

        if is_goal_state(current_state):
            return path

        if current_state in visited:
            continue

        visited.add(current_state)

        print('Next Possible States: ', get_next_possible_states(current_state))
        for successor in get_next_possible_states(current_state):
            if successor not in visited:
                priority_queue.put((heuristic(successor), successor))

    return None

def a_star_search(init):
    priority_queue = PriorityQueue()
    priority_queue.put((heuristic(init), init))
    visited = set()
    path = []
    g_values = {init: 0}

    while priority_queue:
        current_state = priority_queue.get()[1]
        path = path + [current_state]
        print('Current State: ', current_state)

        if is_goal_state(current_state):
            return path

        if current_state in visited:
            continue

        visited.add(current_state)

        print('Next Possible States: ', get_next_possible_states(current_state))
        for next_state in get_next_possible_states(current_state):
            g_value = g_values[current_state] + 1
            if next_state not in g_values or g_value < g_values[next_state]:
                g_values[next_state] = g_value
                f_value = g_value + heuristic(next_state)
                priority_queue.put((f_value, next_state))

    return None

def display(algorithm, result):
    if result:
        print('\n' + algorithm + ' Solution:\n')
        for i, state in enumerate(result):
            left_pos, right_pos, boat_pos = state
            print(f"Step {i + 1}: Left: {left_pos} - Right: {right_pos} - Boat: {('left' if boat_pos == 'l' else 'right')}")
    else:
        print("No Solution...")

def driver_breadth_first_search():
    init = get_initial_state()
    print('\n\nRunning Breadth First Search:\n')
    result = bfs(init)
    display('Breadth First Search', result)

def driver_depth_first_search():
    init = get_initial_state()
    visited = set()
    path = [init]
    print('\n\nRunning Depth First Search:\n')
    result = dfs(init, path, visited)
    display('Depth First Search', result)

def driver_greedy_best_first_search():
    init = get_initial_state()
    print('\n\nRunning Greedy Best First Search:\n')
    result = greedy_best_first_search(init)
    display('Greedy Best First Search', result)

def driver_a_star_search():
    init = get_initial_state()
    print('\n\nRunning A* Search:\n')
    result = a_star_search(init)
    display('A* Search', result)

# Call BFS, DFS, GBFS, A*S...

driver_breadth_first_search()
driver_depth_first_search()
driver_greedy_best_first_search()
driver_a_star_search()